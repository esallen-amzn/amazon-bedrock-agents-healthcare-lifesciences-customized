#!/bin/bash
#
# Auto-generated script to fix line endings (CRLF -> LF)
# Generated by Windows-to-Mac migration checker
#
# This script safely converts Windows line endings (CRLF) to Unix line endings (LF) with:
# - Validation of files before modification
# - Backup creation (optional)
# - Support for both dos2unix and sed
# - Detailed logging
# - Error handling
#

set -e  # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
CREATE_BACKUP=false
BACKUP_DIR="backups/line_endings_$(date +%Y%m%d_%H%M%S)"
DRY_RUN=false
USE_DOS2UNIX=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --backup)
            CREATE_BACKUP=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help)
            echo "Usage: $0 [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --backup    Create backups of files before fixing"
            echo "  --dry-run   Show what would be done without making changes"
            echo "  --help      Show this help message"
            echo ""
            echo "This script converts Windows line endings (CRLF) to Unix line endings (LF)."
            echo "It will use dos2unix if available, otherwise falls back to sed."
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

echo -e "${GREEN}Fixing line endings (CRLF -> LF)...${NC}"
echo ""

if [ "$DRY_RUN" = true ]; then
    echo -e "${YELLOW}DRY RUN MODE - No changes will be made${NC}"
    echo ""
fi

# Check if dos2unix is available
if command -v dos2unix &> /dev/null; then
    echo -e "${BLUE}✓ Using dos2unix for conversion${NC}"
    USE_DOS2UNIX=true
else
    echo -e "${YELLOW}⚠ dos2unix not found, using sed for conversion${NC}"
    echo -e "${YELLOW}  To install dos2unix: brew install dos2unix${NC}"
    USE_DOS2UNIX=false
fi
echo ""

if [ "$CREATE_BACKUP" = true ] && [ "$DRY_RUN" = false ]; then
    echo "Creating backup directory: $BACKUP_DIR"
    mkdir -p "$BACKUP_DIR"
    echo ""
fi

# Counter for statistics
TOTAL_FILES=0
FIXED_FILES=0
SKIPPED_FILES=0
FAILED_FILES=0

# Function to check if file has CRLF line endings
has_crlf() {
    local file=$1
    if [ ! -f "$file" ]; then
        return 1
    fi
    # Check for CRLF (\r\n) in the file
    if grep -q $'\r' "$file" 2>/dev/null; then
        return 0  # Has CRLF
    else
        return 1  # No CRLF
    fi
}

# Function to fix line endings in a file
fix_line_endings() {
    local file=$1
    TOTAL_FILES=$((TOTAL_FILES + 1))
    
    # Check if file exists
    if [ ! -f "$file" ]; then
        echo -e "${RED}✗ File not found: $file${NC}"
        FAILED_FILES=$((FAILED_FILES + 1))
        return 1
    fi
    
    # Check if file has CRLF
    if ! has_crlf "$file"; then
        echo -e "${YELLOW}○ Already has LF endings: $file${NC}"
        SKIPPED_FILES=$((SKIPPED_FILES + 1))
        return 0
    fi
    
    # Create backup if requested
    if [ "$CREATE_BACKUP" = true ] && [ "$DRY_RUN" = false ]; then
        backup_file="$BACKUP_DIR/$(echo $file | tr '/' '_')"
        cp "$file" "$backup_file"
        echo "$file -> $backup_file" >> "$BACKUP_DIR/backup.log"
    fi
    
    # Fix line endings
    if [ "$DRY_RUN" = true ]; then
        echo -e "${GREEN}✓ Would fix: $file${NC}"
        FIXED_FILES=$((FIXED_FILES + 1))
    else
        if [ "$USE_DOS2UNIX" = true ]; then
            if dos2unix "$file" 2>/dev/null; then
                echo -e "${GREEN}✓ Fixed (dos2unix): $file${NC}"
                FIXED_FILES=$((FIXED_FILES + 1))
            else
                echo -e "${RED}✗ Failed to fix: $file${NC}"
                FAILED_FILES=$((FAILED_FILES + 1))
                return 1
            fi
        else
            # Use sed as fallback
            # macOS sed requires '' after -i, Linux sed doesn't
            if sed -i '' 's/\r$//' "$file" 2>/dev/null || sed -i 's/\r$//' "$file" 2>/dev/null; then
                echo -e "${GREEN}✓ Fixed (sed): $file${NC}"
                FIXED_FILES=$((FIXED_FILES + 1))
            else
                echo -e "${RED}✗ Failed to fix: $file${NC}"
                FAILED_FILES=$((FAILED_FILES + 1))
                return 1
            fi
        fi
    fi
    
    return 0
}

# Function to scan and fix files by pattern
scan_and_fix() {
    local pattern=$1
    local description=$2
    
    echo -e "${BLUE}Scanning for $description...${NC}"
    
    # Find files matching pattern
    local files_found=0
    while IFS= read -r -d '' file; do
        files_found=$((files_found + 1))
        fix_line_endings "$file"
    done < <(find . -type f -name "$pattern" -not -path "*/\.*" -not -path "*/node_modules/*" -not -path "*/venv/*" -not -path "*/.venv/*" -not -path "*/build/*" -not -path "*/dist/*" -print0 2>/dev/null)
    
    if [ $files_found -eq 0 ]; then
        echo -e "${YELLOW}  No $description found${NC}"
    fi
    echo ""
}

# Fix files by type
echo "Processing files..."
echo ""

# Shell scripts (critical)
scan_and_fix "*.sh" "shell scripts"

# Python files (critical)
scan_and_fix "*.py" "Python files"

# Configuration files (warning)
scan_and_fix "*.yaml" "YAML files"
scan_and_fix "*.yml" "YML files"
scan_and_fix "*.json" "JSON files"

# Documentation files (warning)
scan_and_fix "*.md" "Markdown files"
scan_and_fix "*.txt" "text files"

# Print summary
echo ""
echo "=========================================="
echo "Summary:"
echo "=========================================="
echo "Total files processed: $TOTAL_FILES"
if [ "$DRY_RUN" = false ]; then
    echo -e "${GREEN}Fixed: $FIXED_FILES${NC}"
    echo -e "${YELLOW}Already correct: $SKIPPED_FILES${NC}"
    if [ $FAILED_FILES -gt 0 ]; then
        echo -e "${RED}Failed: $FAILED_FILES${NC}"
    fi
else
    echo "Would fix: $FIXED_FILES"
    echo "Already correct: $SKIPPED_FILES"
fi
echo "=========================================="

if [ "$CREATE_BACKUP" = true ] && [ "$DRY_RUN" = false ]; then
    echo ""
    echo "Backups created in: $BACKUP_DIR"
    echo "To restore files, use:"
    echo "  while IFS=' -> ' read -r original backup; do cp \"\$backup\" \"\$original\"; done < $BACKUP_DIR/backup.log"
fi

if [ "$DRY_RUN" = false ]; then
    echo ""
    if [ $FIXED_FILES -gt 0 ]; then
        echo -e "${GREEN}All line endings fixed successfully!${NC}"
    else
        echo -e "${GREEN}No line ending issues found!${NC}"
    fi
else
    echo ""
    echo -e "${YELLOW}Dry run complete. Run without --dry-run to apply changes.${NC}"
fi

# Exit with error if any files failed
if [ $FAILED_FILES -gt 0 ]; then
    exit 1
fi

exit 0
